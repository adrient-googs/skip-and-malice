// Generated by CoffeeScript 1.3.3

/*
Useful Utilities
*/


(function() {
  var RemoteModel, chatter, openChannel, util,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  util = util != null ? util : {};

  util.assertion = function(condition, err_msg) {
    if (!condition) {
      alert(err_msg);
      throw new Error(err_msg);
    }
  };

  util.flip = function(func) {
    return function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return func.apply(null, args.slice(0).reverse());
    };
  };

  util.later = function() {
    var args, func, ms, _ref, _ref1;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (args.length === 1) {
      _ref = [args[0], 1], func = _ref[0], ms = _ref[1];
    } else if (args.length === 2) {
      _ref1 = [args[1], args[0]], func = _ref1[0], ms = _ref1[1];
    } else {
      throw new Error('util.later takes 1 or 2 arguments only.');
    }
    return setTimeout(func, ms);
  };

  util.titleCase = function(str) {
    return str.replace(/\w\S*/g, function(txt) {
      return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
    });
  };

  util.prettyUsername = function(name) {
    var at_index;
    at_index = name.indexOf('@');
    if (at_index > 0) {
      return name.slice(0, at_index);
    } else {
      return name;
    }
  };

  util.mash = function(array) {
    var dict, key, key_value, value, _i, _len;
    dict = {};
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      key_value = array[_i];
      key = key_value[0], value = key_value[1];
      dict[key] = value;
    }
    return dict;
  };

  util.isInteger = function(obj) {
    return _.isNumber(obj) && (obj % 1 === 0);
  };

  util.typeName = function(obj) {
    if (!(obj != null)) {
      return 'undefined';
    }
    return obj.__proto__.constructor.name;
  };

  util.setCollectionAsAttribute = function(model, collection_name, initial_elts) {
    var collection,
      _this = this;
    if (initial_elts == null) {
      initial_elts = [];
    }
    collection = new Backbone.Collection(initial_elts);
    model[collection_name] = collection;
    model.set(collection_name, collection.models);
    collection.on('add remove change', function() {
      console.log(" --- updating " + (util.typeName(model)) + " based on collection change");
      return model.attributes[collection_name] = collection.models;
    });
    model.on("change:" + collection_name, function() {
      console.log(" --- updating collection based on " + (util.typeName(model)) + " change");
      return collection.reset(model.attributes[collection_name]);
    });
    return collection.on('all', function() {
      var args, type;
      type = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return model.trigger.apply(model, ["" + collection_name + ":" + type].concat(__slice.call(args)));
    });
  };

  util.timeStr = function(hour) {
    var suf, _ref;
    if (hour === 12) {
      return 'noon';
    }
    _ref = hour < 12 ? [hour, 'am'] : hour < 13 ? [hour, 'pm'] : [hour - 12, 'pm'], hour = _ref[0], suf = _ref[1];
    if (util.isInteger(hour)) {
      return "" + hour + suf;
    } else {
      return "" + (Math.floor(hour)) + ":30" + suf;
    }
  };

  util.WEEKDAYS = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

  util.randInt = function(max) {
    return Math.floor(Math.random() * max);
  };

  util.choose = function(array, exclude) {
    var elt;
    if (exclude == null) {
      exclude = [];
    }
    while (true) {
      elt = array[util.randInt(array.length)];
      if (__indexOf.call(exclude, elt) < 0) {
        return elt;
      }
    }
  };

  util.uid = function() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r;
      r = util.randInt(16);
      return (c === 'x' ? r : r & 0x3 | 0x8).toString(16);
    });
  };

  /*
    Performs each action with a given probability, e.g.
  
      util.withProbability [
        0.25, -> action A
        0.50, -> action B
        null, -> action C
      ]
  
    performs action A with probability 0.25, action B with
    probability 0.5 and action C with the remaining 0.25
    probability.
  */


  util.withProbability = function(actions) {
    var action, ii, prob, random, _i, _ref, _ref1;
    random = Math.random();
    for (ii = _i = 0, _ref = actions.length; _i < _ref; ii = _i += 2) {
      _ref1 = actions.slice(ii, (ii + 1) + 1 || 9e9), prob = _ref1[0], action = _ref1[1];
      if (!(prob != null) || (random -= prob) < 0) {
        return action();
      }
    }
  };

  /*
    Appends an element to a div assuming all elements are laid
    out as follows:
  
      ELT   height
      SPACE vertical_margin
      ELT   height
      SPACE vertical_margin
      ELT   height
  
    Also, resizes the containing div.
  */


  util.verticalAppend = function(elt, container, height, vertical_margin) {
    var n_children;
    n_children = container.children().length;
    elt.css({
      height: height,
      top: n_children * (height + vertical_margin)
    });
    container.css({
      height: height * (n_children + 1) + vertical_margin * n_children
    });
    return container.append(elt);
  };

  /*
    Opens a channel to the server and delegates message calls to the
    delegate object.
  */


  openChannel = function(token, delegate) {
    var channel;
    channel = new goog.appengine.Channel(token);
    return channel.open({
      onopen: function() {
        return typeof delegate.channel_open === "function" ? delegate.channel_open() : void 0;
      },
      onclose: function() {
        return typeof delegate.channel_close === "function" ? delegate.channel_close() : void 0;
      },
      onerror: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return typeof delegate.channel_error === "function" ? delegate.channel_error.apply(delegate, args) : void 0;
      },
      onmessage: function(message) {
        var args, method, _ref;
        _ref = chatter.unwrap(JSON.parse(message.data)), method = _ref[0], args = _ref[1];
        console.log('ONMESSAGE');
        console.log(method);
        console.log(args);
        console.log(_.keys(delegate));
        return delegate[method](args);
      }
    });
  };

  /*
  Enables serialization (wrapping) and deserialization (unwrapping) of
  arbitrary objects according to the chatter protocol.
  */


  chatter = chatter != null ? chatter : {};

  chatter.unwrap_table = {};

  chatter.register = function(type) {
    return chatter.unwrap_table[type.name] = type;
  };

  chatter.wrap = function(obj) {
    var key, value, x;
    if (_.isFunction(obj != null ? obj.wrap : void 0)) {
      return obj.wrap();
    } else if (_.isUndefined(obj)) {
      return ['NoneType', ''];
    } else if (_.isNull(obj)) {
      return ['NoneType', ''];
    } else if (_.isBoolean(obj)) {
      return ['bool', obj];
    } else if (util.isInteger(obj)) {
      return ['int', obj];
    } else if (_.isNumber(obj)) {
      return ['float', obj];
    } else if (_.isString(obj)) {
      return ['str', obj];
    } else if (_.isArray(obj)) {
      return [
        'list', (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = obj.length; _i < _len; _i++) {
            x = obj[_i];
            _results.push(chatter.wrap(x));
          }
          return _results;
        })()
      ];
    } else if (_.isObject(obj)) {
      console.log("wrapping object keys: " + (_.keys(obj)));
      return [
        'dict', chatter.wrap((function() {
          var _results;
          _results = [];
          for (key in obj) {
            value = obj[key];
            _results.push([key, value]);
          }
          return _results;
        })())
      ];
    } else {
      throw new Error("cannot wrap " + obj);
    }
  };

  chatter.unwrap = function(obj) {
    var attribs, data, key, type, type_name, value, x, _i, _len, _results;
    type_name = obj[0], data = obj[1];
    type = chatter.unwrap_table[type_name];
    if (type != null) {
      attribs = util.mash((function() {
        var _results;
        _results = [];
        for (key in data) {
          value = data[key];
          _results.push([key, chatter.unwrap(value)]);
        }
        return _results;
      })());
      console.log("unwrapping!!! " + type.name);
      return new type(attribs);
    } else {
      switch (type_name) {
        case 'list':
          _results = [];
          for (_i = 0, _len = data.length; _i < _len; _i++) {
            x = data[_i];
            _results.push(chatter.unwrap(x));
          }
          return _results;
        case 'dict':
          return util.mash(chatter.unwrap(data));
        case 'int':
        case 'long':
        case 'unicode':
        case 'str':
        case 'float':
          return data;
        case 'NoneType':
          return void 0;
        default:
          throw new Error("type_name \"" + type_name + "\" not understood");
      }
    }
  };

  /*
  Enables serialization (wrapping) and deserialization (unwrapping) of
  arbitrary objects according to the chatter protocol.
  */


  /*
  Enables entities and methods to be serialized across the internet.
  */


  RemoteModel = (function(_super) {
    var _this = this;

    __extends(RemoteModel, _super);

    function RemoteModel() {
      return RemoteModel.__super__.constructor.apply(this, arguments);
    }

    RemoteModel.prototype.urlRoot = function() {
      return "" + this.__proto__.constructor.name + "/datastore";
    };

    RemoteModel.prototype.parse = function(obj) {
      var data, key, my_name, type_name, value;
      my_name = this.__proto__.constructor.name;
      type_name = obj[0], data = obj[1];
      util.assertion(my_name === type_name, "" + my_name + " cannot parse " + type_name);
      return util.mash((function() {
        var _results;
        _results = [];
        for (key in data) {
          value = data[key];
          _results.push([key, chatter.unwrap(value)]);
        }
        return _results;
      })());
    };

    RemoteModel.prototype.toJSON = function() {
      var key, my_name, value, wrapped_attribs;
      my_name = this.__proto__.constructor.name;
      console.log("RemoteModel wrapping " + my_name + " attribs: " + (_.keys(this.attributes)));
      if (this.attributes.calEvents != null) {
        console.log("HAS calEvents, length:" + this.attributes.calEvents.length);
      }
      wrapped_attribs = (function() {
        var _ref, _results;
        _ref = this.attributes;
        _results = [];
        for (key in _ref) {
          value = _ref[key];
          _results.push([key, chatter.wrap(value)]);
        }
        return _results;
      }).call(this);
      return [my_name, util.mash(wrapped_attribs)];
    };

    RemoteModel.prototype.wrap = function() {
      return this.toJSON();
    };

    /*
      To declare a remote static method:
        @funcName: RemoteModel.remoteStaticMethod 'funcName'
      To catch errors, bind an object to the "ajaxError" event.
    */


    RemoteModel.remoteStaticMethod = function(name) {
      return function() {
        var args, done, method_args, _ref;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        _ref = (function() {
          switch (args.length) {
            case 0:
              return [{}, function() {}];
            case 1:
              if (_.isFunction(args[0])) {
                return [{}, args[0]];
              } else {
                return [args[0], function() {}];
              }
            case 2:
              return args;
            default:
              throw new Error('Too many arguements.');
          }
        })(), method_args = _ref[0], done = _ref[1];
        return $.post("" + this.prototype.constructor.name + "/method/" + name, JSON.stringify(chatter.wrap({
          args: method_args
        })), function(response) {
          return done(chatter.unwrap(response).return_val);
        });
      };
    };

    /*
      To declare a remote instance method:
    
        funcName: RemoteModel.remoteInstanceMethod 'funcName', options
    
      Options:
      
        sync_before (default=false) : save to server before remote method invocation
        sync_after (default=false)  : fetch from server after remote method invocation
    
      To catch errors, bind an object to the "ajaxError" event.
    */


    RemoteModel.remoteInstanceMethod = function(name, options) {
      if (options == null) {
        options = {};
      }
      return function() {
        var args, done, method_args, request, _ref, _ref1, _ref2,
          _this = this;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        _ref = (function() {
          switch (args.length) {
            case 0:
              return [{}, function() {}];
            case 1:
              if (_.isFunction(args[0])) {
                return [{}, args[0]];
              } else {
                return [args[0], function() {}];
              }
            case 2:
              return args;
            default:
              throw new Error('Too many arguements.');
          }
        })(), method_args = _ref[0], done = _ref[1];
        request = {
          args: method_args,
          sync_before: (_ref1 = options.sync_before) != null ? _ref1 : false,
          sync_after: (_ref2 = options.sync_after) != null ? _ref2 : false
        };
        if (request.sync_before) {
          request.self = this;
        }
        return $.post("" + this.__proto__.constructor.name + "/method/" + name + "/" + this.id, JSON.stringify(chatter.wrap(request)), function(response) {
          response = chatter.unwrap(response);
          if (request.sync_after) {
            util.assertion(response.self.id === _this.id, 'ID cannot be reset.');
            _this.set(response.self.attributes);
          }
          return done(response.return_val);
        });
      };
    };

    return RemoteModel;

  }).call(this, Backbone.Model);

  $(function() {
    return $('body').append('hello world');
  });

}).call(this);
